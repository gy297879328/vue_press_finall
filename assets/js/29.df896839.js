(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{569:function(t,a,s){"use strict";s.r(a);var e=s(6),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"内存屏障的介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障的介绍"}},[t._v("#")]),t._v(" 内存屏障的介绍")]),t._v(" "),s("p",[t._v("为了禁止编译器重排序和 CPU 重排序，在编译器和 CPU 层面都有对应的指令，也就是"),s("code",[t._v("内存屏障")]),t._v("（Memory Barrier）又称内存栅栏。这也正是JMM和happen-before规则的底层实现原理。是一个CPU指令，")]),t._v(" "),s("p",[t._v("它的作用有两个，")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("一是"),s("code",[t._v("保证特定操作的执行顺序")])])]),t._v(" "),s("li",[s("p",[t._v("二是"),s("code",[t._v("保证某些变量的内存可见性")]),t._v("（利用该特性实现volatile的内存可见性）。")]),t._v(" "),s("p",[t._v("由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Memory Barrier的另外一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本")]),t._v("。")]),t._v(" "),s("p",[t._v("总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。")])])]),t._v(" "),s("h1",{attrs:{id:"jvm级别如何规范-jsr133"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jvm级别如何规范-jsr133"}},[t._v("#")]),t._v(" JVM级别如何规范(JSR133)")]),t._v(" "),s("p",[t._v("编译器的内存屏障，只是为了告诉编译器不要对指令进行重排序。当编译完成之后，这种内存屏障就消失了，CPU并不会感知到编译器中内存屏障的存在。")]),t._v(" "),s("p",[t._v("而CPU的内存屏障是CPU提供的指令，可以由开发者显示调用。内存屏障是很底层的概念，对于 Java 开发者来说，一般用 "),s("RouterLink",{attrs:{to:"/note/java/2021/morethread/key_volatile.html"}},[t._v("volatile")]),t._v(" 关键字就足够了。但从JDK 8开始，Java在Unsafe类中提供了三个内存屏障函数，如下所示。")],1),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Unsafe")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("native")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("loadFence")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("native")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("storeFence")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("native")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fullFence")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[t._v("在理论层面，可以把基本的CPU内存屏障分成四种：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("屏障类型")]),t._v(" "),s("th",[t._v("指令示例")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("LoadLoad")]),t._v(" "),s("td",[t._v("Load1; LoadLoad; Load2")]),t._v(" "),s("td",[t._v("禁止读和读的重排序(保证load1的读取操作在load2及后续读取操作之前执行)")])]),t._v(" "),s("tr",[s("td",[t._v("StoreStore")]),t._v(" "),s("td",[t._v("Store1; StoreStore; Store2")]),t._v(" "),s("td",[t._v("禁止写和写的重排序(在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存)")])]),t._v(" "),s("tr",[s("td",[t._v("LoadStore")]),t._v(" "),s("td",[t._v("Load1; LoadStore; Store2")]),t._v(" "),s("td",[t._v("禁止读和写的重排序(在stroe2及其后的写操作执行前，保证load1的读操作已读取结束)")])]),t._v(" "),s("tr",[s("td",[t._v("StoreLoad")]),t._v(" "),s("td",[t._v("Store1; StoreLoad; Load2")]),t._v(" "),s("td",[t._v("禁止写和读的重排序(保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行)")])])])]),t._v(" "),s("p",[t._v("​\t不同的基本内存屏障可以禁止对应的内存重排序。")]),t._v(" "),s("p",[s("strong",[t._v("比如StoreLoad屏障，指该屏障前的所有写操作的结果都要早于屏障后的读操作而提交到主内存或高速缓存中。")])]),t._v(" "),s("p",[t._v("Unsafe中的方法：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("loadFence=LoadLoad+LoadStore")])]),t._v(" "),s("li",[s("p",[t._v("storeFence=StoreStore+LoadStore")])]),t._v(" "),s("li",[s("p",[t._v("fullFence=loadFence+storeFence+StoreLoad")])])]),t._v(" "),s("h1",{attrs:{id:"几种内存屏障的简单说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#几种内存屏障的简单说明"}},[t._v("#")]),t._v(" 几种内存屏障的简单说明")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("可见性保障来划分。内存屏障可分为"),s("strong",[t._v("加载屏障")]),t._v("（Load Barrier）和"),s("strong",[t._v("存储屏障")]),t._v("（Store  Barrier）。")]),t._v(" "),s("p",[s("strong",[t._v("加载屏障的作用是刷新处理器缓存，存储屏障的作用冲刷处理器缓存")]),t._v("。")])])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Java 虚拟机会在 MonitorEnter （ 申请锁 ） 对应的机器码指令之后临界区开始之前的地方插入一个"),s("code",[t._v("加载屏障")]),t._v("，这使得"),s("strong",[t._v("读线程的执行处理器能够将写线程对相应共享变量所做的更新从其他处理器同步到该处理器的高速缓存中")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("Java虚拟机会在 MonitorExit （ 释放锁 ） 对应的机器码指令之后插入一个"),s("code",[t._v("存储屏障")]),t._v("，这就"),s("strong",[t._v("保障了写线程在释放锁之前在临界区中对共享变量所做的更新对读线程的执行处理器来说是可同步的")]),t._v("。")]),t._v(" "),s("p",[t._v("相应地，可见性的保障是通过写线程和读线程成对地使用存储屏障和加载屏障实现的。")])])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("按照有序性保障来划分，内存屏障可以分为"),s("strong",[t._v("获取屏障")]),t._v("（Acquire Barrier）和"),s("strong",[t._v("释放屏障")]),t._v(" （ Release Barrier )")])]),t._v(" "),s("ul",[s("li",[t._v("Acquire "),s("code",[t._v("获取屏障")]),t._v("的使用方式是在一个读操作之后"),s("code",[t._v("插入该内存屏障")]),t._v("，其作用是"),s("strong",[t._v("禁止该读操作与其后的任何读写操作之间进行重排序")]),t._v("，这相当于在进行后续操作之前先要获得相应共享数据的所有权 （ 这也是该屏障的名称来源 ）。")]),t._v(" "),s("li",[t._v("Release "),s("code",[t._v("释放屏障")]),t._v("的使用方式是在一个写操作之前"),s("code",[t._v("插入该内存屏障")]),t._v("，其作用是"),s("strong",[t._v("禁止该写操作与其前面的任何读写操作之间进行重排序")]),t._v("。这相当于在对相应共享数据操作结束后释放所有权（ 这也是该屏障的名称来源 ）。\nJava虚拟机会在 MonitorEnter（ 它包含了读操作 ） 对应的机器码指令之后临界区开始之前的地方插入一个获取屏障，并在临界区结束之后 MonitorExit （ 它包含了写操作 ） 对应的机器码指令之前的地方插入一个释放屏障。因此，这两种屏障就像是三明治的两层面包片把火腿夹住一样把临界区中的代码（指令序列\n"),s("strong",[t._v("Acquire屏障其实就是LoadLoad屏障 + LoadStore屏障，Release屏障其实就是StoreLoad屏障 + StoreStore屏障")]),t._v(" ，这个和虚拟机具体实现有关仅仅做一个记忆参考")])]),t._v(" "),s("h1",{attrs:{id:"内存屏障的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障的使用"}},[t._v("#")]),t._v(" 内存屏障的使用")]),t._v(" "),s("h2",{attrs:{id:"_1-synchronized实现可见性的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-synchronized实现可见性的原理"}},[t._v("#")]),t._v(" 1. synchronized实现可见性的原理")]),t._v(" "),s("p",[t._v("简单地说"),s("strong",[t._v("可见性就是把工作内存中的数据刷入主内存，加载数据")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" monitorenter \n\n\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Load")]),t._v("内存屏障 \n\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Acquire")]),t._v("内存屏障 \n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\tc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v("代码块里面还是可能会发生指令重排 \n\n\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Release")]),t._v("内存屏障 \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" monitorexit \n\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Store")]),t._v("内存屏障 \n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br")])]),s("p",[s("img",{attrs:{src:"D:/javanode/javanode/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/synchronized/synchronized_monenrty.png",alt:"synchronized_monenrty"}})]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Load屏障的作用是执行refresh处理器缓存的操作，说白了就是对别的处理器更新过来变量，从"),s("strong",[t._v("其他处理器的高速缓存（或者主内存） 加载数据到自己的高速缓存来")]),t._v("，确保自己看到的是最新的数据。")])]),t._v(" "),s("li",[s("p",[t._v("Store屏障的作用是执行flush处理器缓存的操作，说白了就是把自己当前"),s("strong",[t._v("处理器更新的变量的值，都刷新到高速缓存（或者主内存）里去")])])])]),t._v(" "),s("p",[t._v("基于synchronized代码块字节码层面上来说：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("在moniterenter指令之后，加入了一个load屏障，执行一个refresh操作从其他处理器的高速缓存读取最新数据或者从主内存加载数据")])]),t._v(" "),s("li",[s("p",[t._v("在moniterexit指令之后，加入一个store屏障，执行flush操作，把最新值写入高速缓存或者主内存")])])]),t._v(" "),s("h2",{attrs:{id:"_2-volatile-禁止重排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-volatile-禁止重排序"}},[t._v("#")]),t._v(" 2. volatile 禁止重排序")]),t._v(" "),s("p",[t._v("Java中volatile关键字具有禁止重排序和提供共享变量在多线程中的可见性的能力。这两个能力就是依赖于内存屏障而产生的。")]),t._v(" "),s("h2",{attrs:{id:"_3-final域的重排序规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-final域的重排序规则"}},[t._v("#")]),t._v(" 3. final域的重排序规则：")]),t._v(" "),s("p",[t._v("在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序；")]),t._v(" "),s("p",[t._v("初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。")])])}),[],!1,null,null,null);a.default=r.exports}}]);